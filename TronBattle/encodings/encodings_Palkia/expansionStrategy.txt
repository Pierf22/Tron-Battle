% ----- MODULO DI CONQUISTA TERRITORIALE -----
finalMovePalkia(X, Y) | nonFinalMovePalkia(X, Y) :- nextCellPalkia(X, Y). % una cella adiacente al player può essere la mossa finale (successiva) oppure no

% Vincolo che impone di avere almeno una finalMove:
:- not existsFinalMovePalkia.
existsFinalMovePalkia :- finalMovePalkia(X, Y).

% CONSTRAINT
% ----- 1° constraint (deve fare in modo di non finire in un vicolo cieco) -----
maxNumCellPalkia(Cmax) :- #max{C : indirectCellPalkia(_, _, C)} = Cmax. % prendo il valore massimo di celle indirette raggiungibili da una nextCell
:~ finalMovePalkia(X, Y), indirectCellPalkia(X, Y, C), maxNumCellPalkia(Cmax). [Cmax-C@3]   % gli dico di preferire una cella che gl permette di avere più strada disponibile

% ----- 2° constraint (deve andare verso la cella con più spazio libero adiacente) -----
maxIndirectCellDepthPalkia(Dmax) :- #max{D : indirectCellDepthPalkia(_, _, D)} = Dmax.
:~ finalMovePalkia(X, Y), indirectCellDepthPalkia(X, Y, D), maxIndirectCellDepthPalkia(Dmax). [Dmax-D@2]

% ----- 3° constraint (deve cercare di stare il più lontano possibile da tutti i nemici) -----
maxDistanceFromEnemiesPalkia(Dmax) :- #max{D : distanceFromEnemiesPalkia(_, _, D)} = Dmax.
:~ finalMovePalkia(X, Y), distanceFromEnemiesPalkia(X, Y, D), maxDistanceFromEnemiesPalkia(Dmax). [Dmax-D@1]

% Prendo la/e mossa/e successiva che vuoi fare:
#show finalMovePalkia/2.